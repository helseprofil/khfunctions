#' @title load_and_format_files
#' @description
#' Loads filegroups as specified in parameters$files
#' Adds FileDesign to parameter list after loading files
#' Teller file is loaded first, and other files are filtered according to years present in this file
#' Files are always loaded fresh into BUFFER, and overwritten if they already exist. 
#' @param parameters list of parameters generated by get_cubeparameters()
#' @return updated parameter list after loading and formatting files
load_and_format_files <- function(parameters){
  cat("\n* Laster og formatterer filgrupper\n")
  if(!exists("BUFFER", envir = .GlobalEnv)) .GlobalEnv$BUFFER <- list()
  tabfilter_tellerfile <- set_filter_tab(cubeinformation = parameters$CUBEinformation)
  tellerfile <- parameters$files$TELLER
  isbuffer <- tellerfile %in% names(.GlobalEnv$BUFFER)
  if(isbuffer) BUFFER[[tellerfile]] <- NULL
  load_filegroup_to_buffer(filegroup = tellerfile, filter = tabfilter_tellerfile, parameters = parameters)
  
  nonteller_files <- unique(grep(paste0("^", tellerfile, "$"), parameters$files, invert = T, value = T))
  for (file in nonteller_files) {
    isbuffer <- file %in% names(BUFFER)
    if(isbuffer) BUFFER[[file]] <- NULL
    load_filegroup_to_buffer(filegroup = file, filter = NULL, parameters = parameters)
  }
  invisible(gc())
}

#' @title set_filter_tab
#' @description
#' Creates a filtering string based on the TABX and TABX_0 columns in table KUBER in ACCESS
#' If TABX_0 is provided, this is used for initial filtering of the filegroup, as these categories are needed during the data processing.
#' TABX is always used for final filtering of the cube.
#' @param cubeinformation information from table KUBER in ACCESS
#' @noRd
set_filter_tab <- function(cubeinformation){
  TabConds <- character()
  for (tab in names(cubeinformation)[grepl("^TAB\\d+$", names(cubeinformation))]){
    istab <- !is.na(cubeinformation[[tab]]) && cubeinformation[[tab]] != ""
    if (istab) {
      tab0 <- paste0(tab, "_0")
      istab0 <- !is.null(cubeinformation[[tab0]]) && !is.na(cubeinformation[[tab0]]) && cubeinformation[[tab0]] != ""
      tablist <- cubeinformation[[tab]]
      if(istab0) tablist <- cubeinformation[[tab0]]
      isminus <- grepl("^-\\[", tablist)
      tablist <- gsub("^-\\[(.*)\\]$", "\\1", tablist)
      tablist <- paste0("\"", gsub(",", "\",\"", tablist), "\"")
      tabcond <- paste0("(", tab, " %in% c(", tablist, "))")
      if (isminus) tabcond <- paste0("!", tabcond)
      TabConds <- c(TabConds, tabcond)
    }
  } 
  tabfilter <- paste0(TabConds, collapse = " & ")
  if(tabfilter == "") tabfilter <- NULL
  return(tabfilter)
}

#' @title do_filter_columns
#' @description
#' Filters file according to filtering string, such as tabfilter generated by
#' @param file file to filter
#' @param filter filtering string
#' @noRd
do_filter_columns <- function(file, filter){
  file <- file[eval(rlang::parse_expr(filter))]
  return(file)
}

#' @title load_filegroup_to_buffer
#' @description
#' Loads the file into BUFFER in .GlobalEnv
#' The file is filtered using TABfilter and geoharmonized. 
#' If filefilter is defined, the file is formatted accordingly
#' @noRd
load_filegroup_to_buffer <- function(filegroup, filter = NULL, parameters){
  filefilter <- parameters$FILFILTRE[FILVERSJON == filegroup]
  isfilefilter <- nrow(filefilter) > 0
  alderfilter <- set_filter_age(parameters = parameters)
  yearfilter <- set_filter_year(parameters = parameters)
  filter <- paste0(c(filter, alderfilter, yearfilter), collapse = " & ")
  isfilter <- is_not_empty(filter)
  fileinfo <- parameters$fileinformation[[filegroup]]
  orgfile <- ifelse(isfilefilter, filefilter$ORGFIL, filegroup)
  
  FIL <- read_filegroup(orgfile)
  if(isfilter) FIL <- do_filter_columns(file = FIL, filter = filter)
 
  if(!isfilefilter){
    FIL <- do_harmonize_geo(file = FIL, vals = fileinfo$vals, rectangularize = FALSE, parameters = parameters)
    .GlobalEnv$BUFFER[[filegroup]] <- FIL
    return(invisible(NULL))
  } 
  
  if(isfilefilter){
    iskollapsdel <- grepl("\\S", filefilter$KOLLAPSdeler)
    if(iskollapsdel) FIL <- do_filfiltre_kollapsdeler(file = FIL, parts = filefilter$KOLLAPSdeler, parameters = parameters)
    
    isnyekolkolprerad <- grepl("\\S", filefilter$NYEKOL_KOL_preRAD)
    # TODO: optimalisere leggtilnyeverdikolonner
    if(isnyekolkolprerad) add_new_value_columns(dt = FIL, formulas = filefilter$NYEKOL_KOL_preRAD, post_moving_average = FALSE)
    
    # TODO: optimalisere finnredesign (find_redesign) og OmkodFil (recode_file)
    Filter <- set_recode_filter_filfiltre(fileinfo = fileinfo, parameters = parameters)
    if (length(Filter) > 0){
      prefilterdesign <- find_filedesign(FIL, parameters = parameters)
      redesign_filter <- find_redesign(orgdesign = prefilterdesign, targetdesign = list(Parts = Filter), parameters = parameters)
      FIL <- do_filter_and_recode_to_redesign(dt = FIL, redesign = redesign_filter, parameters = parameters)
    }
    
    isgeoharm <- filefilter$GEOHARM == 1
    if(isgeoharm){
      rectangularize <- ifelse(filefilter$REKTISER == 1, TRUE, FALSE)
      FIL <- do_harmonize_geo(file = FIL, vals = fileinfo$vals, rectangularize = rectangularize, parameters = parameters)
    }
    
    isnyekolrad <- grepl("\\S", filefilter$NYEKOL_RAD)
    if(isnyekolrad) FIL <- LeggTilSumFraRader(dt = FIL, NYdscr = filefilter$NYEKOL_RAD, FGP = fileinfo, parameters = parameters)
    
    isnykolsmerge <- grepl("\\S", filefilter$NYKOLSmerge)
    if(isnykolsmerge){
      NY <- eval(parse(text = filefilter$NYKOLSmerge))
      commoncols <- intersect(get_dimension_columns(names(NY)), get_dimension_columns(names(FIL)))
      FIL <- collapse::join(FIL, NY, on = commoncols, how = "l", overid = 2, verbose = 0)
    }
  }
  .GlobalEnv$BUFFER[[filegroup]] <- FIL
  return(invisible(NULL))
}

#' @title set_filter_year
#' @description
#' Sets age filter according to age groups set in ACCESS::KUBER, 
#' @noRd
set_filter_age <- function(parameters){
  isalder <- !is.na(parameters$CUBEinformation$ALDER) && parameters$CUBEinformation$ALDER != ""
  if(!isalder) return(NULL)
  
  accessalder <- unlist(strsplit(parameters$CUBEinformation$ALDER, ","))
  if(any(grepl("[^[:digit:]_]", accessalder))) return(NULL)
  
  aldersplit <- data.table::tstrsplit(accessalder, "_")
  amin <- ifelse(sum(is.na(aldersplit[[1]])) == 0,
                 min(as.numeric(aldersplit[[1]])),
                 getOption("khfunctions.amin"))
  amax <- ifelse(length(aldersplit) > 1 && sum(is.na(aldersplit[[2]])) == 0, 
                 max(as.numeric(aldersplit[[2]])),
                 getOption("khfunctions.amax"))
  
  if(is.na(amin) | is.na(amax)) stop("Feil i aldersfiltreringen, som leser fra ACCESS::KUBER::ALDER. Denne må være tom, 'ALLE', eller angi aldersgrupper separert med komma (X_Y, X_Y, X_Y).")
  return(paste0("ALDERl >= ", amin, " & ALDERh <= ", amax))
}

#' @title set_filter_year
#' @description Filters filegroups to remove years prior to AAR_START in ACCESS::KUBER
#' @keywords internal
#' @noRd
set_filter_year <- function(parameters){
  return(paste0("AARl >= ", parameters$CUBEinformation$AAR_START))
}


#' @title read_filegroup
#' @description Reads original filegroup. Will always read from "NYESTE" folder
#' @keywords internal
#' @noRd
#' @returns data.table
read_filegroup <- function(filegroup){
  file <- file.path(getOption("khfunctions.root"), getOption("khfunctions.filegroups.ny"), paste0(filegroup, ".rds"))
  if(!file.exists(file)) stop("Finner ikke filgruppe: ", file, "! Filgruppen må kjøres først.")
  DT <- data.table::setDT(readRDS(file))
  DT[, (names(.SD)) := NULL, .SDcols = names(DT)[names(DT) %in% c("KOBLID", "ROW")]]
  cat("\n** Lest inn fil: ", file)
  return(DT)
}

#' @title fetch_filegroup_from_buffer
#' @description
#' fetches filegroup already loaded into buffer. 
#' @keywords internal
#' @noRd
fetch_filegroup_from_buffer <- function(filegroup, parameters){
  if(exists("BUFFER", envir = .GlobalEnv) && filegroup %in% names(.GlobalEnv$BUFFER)){
    cat("\n** Henter FIL", filegroup, "fra BUFFER")
    return(data.table::copy(.GlobalEnv$BUFFER[[filegroup]]))
  }
  stop("Filgruppe ", filegroup, " ikke funnet i BUFFER")
}

#' @title do_harmonize_geo
#' @description
#' Harmonizes geographical codes
#' @noRd 
do_harmonize_geo <- function(file, vals = list(), rectangularize = TRUE, parameters) {
  geoomk <- parameters$KnrHarm
  georecode <- sum(collapse::funique(file$GEO) %in% geoomk$GEO)
  if(georecode > 0){
    cat("\n*** Recoding", georecode, "geo-codes")
    file <- collapse::join(file, geoomk, on = "GEO", how = "left", overid = 0, verbose = 0)
    file[!is.na(GEO_omk), let(GEO = GEO_omk)][, let(GEO_omk = NULL, HARMstd = NULL)]
  }
  if("FYLKE" %in% names(file)) file[, FYLKE := NULL]
  file <- do_aggregate_file(file = file, valsumbardef = vals)

  if(rectangularize){
    rectangularized <- data.table::data.table()
    design <- find_filedesign(file, parameters = parameters)
    
    for (Gn in design$Part[["Gn"]][["GEOniv"]]) {
      validgeo <- data.table::data.table(GEO = parameters$GeoKoder[GEOniv == Gn & FRA <= parameters$year & TIL > parameters$year]$GEO)
      designgeo <- design$Design[HAR == 1 & GEOniv == Gn, mget(intersect(names(file), names(design$Design)))]
      rectangularized <- data.table::rbindlist(list(expand.grid.dt(designgeo, validgeo), rectangularized))
    }
    file <- collapse::join(rectangularized, file, how = "l", overid = 0, verbose = 0)
    file <- set_implicit_null_after_merge(file, implicitnull_defs = vals)
  }
  
  file[, FYLKE := ifelse(GEOniv %in% c("H", "L"), "00", substr(GEO, 1, 2))]
  return(file)
}

#' @title do_aggregate_file
#' @description Aggregates file
#' @param file file to aggregate
#' @param valsumbardef list of value column definitions. Not summable values are removed. 
#' @noRd
do_aggregate_file <- function(file, valsumbardef = list()){
  if(!is(file, "data.table")) data.table::setDT(file)
  tabcols <- get_dimension_columns(names(file))
  valcols <- get_value_columns(names(file))
  colorder <- tabcols 
  for(val in valcols){
    file[is.na(get(val)) | get(val) == 0, paste0(val, ".a") := 0]
    colorder <- c(colorder, paste0(val, c("", ".f", ".a")))
  }
  if(!identical(data.table::key(file), tabcols)) data.table::setkeyv(file, tabcols)
  
  g <- collapse::GRP(file, tabcols)
  aggfile <- collapse::add_vars(g[["groups"]],
                                collapse::fsum(collapse::get_vars(file, valcols), g = g),
                                collapse::fmax(collapse::get_vars(file, paste0(valcols, ".f")), g = g),
                                collapse::fsum(collapse::get_vars(file, paste0(valcols, ".a")), g = g))
  
  for(val in valcols){
    if(val %in% names(valsumbardef) && valsumbardef[[val]]$sumbar == 0){
      valA <- paste0(val, ".a")
      valF <- paste0(val, ".f")
      aggfile[get(valA) > 1, c(val, valF) := list(NA, 2)]
    }
  }
  data.table::setcolorder(aggfile, colorder)
  return(aggfile)
}

#' @title do_filfiltre_kollapsdeler
#' @description 
#' collapses file according to the KOLLAPSdeler column in table FILFILTRE
#' @noRd
do_filfiltre_kollapsdeler <- function(file, parts, parameters){
  tabcols <- get_dimension_columns(names(file))
  parts <- unlist(strsplit(parts, ","))
  columns <- as.character(parameters$DefDesign$DelKolsF[parts])
  file[, (columns) := parameters$TotalKoder[parts]]
  cat(paste0("Kollapser kolonnene: ", paste0(columns, collapse = ", "), ". Før er dim "), dim(file))
  file <- file[, collapse::fsum(collapse::gby(.SD, tabcols))]
  cat(" og etter", dim(file), "\n")
  return(file)
}  

#' @title set_recode_filter_filfiltre
#' @description 
#' Uses information from FILFILTRE-columns GEONIV, ALDER, KJONN, UTDANN, LANDBAK, INNVKAT to further filter
#' a file version. This reduces file size by removing rows which is not needed. 
#' Years < KUBER:: AAR_START is already filtered out, and is therefore not included here. 
#' @keywords internal
#' @noRd
set_recode_filter_filfiltre <- function(fileinfo, parameters){
  filters <- parameters$FILFILTRE
  filtercols <- names(filters)[names(filters) %in% grep("^AAR$|^TAB\\d{1}$", parameters$DefDesign$DelKolN, value = T, invert = T)]
  filtercols <- filtercols[sapply(filters[, ..filtercols], function(col) is_not_empty(col))]
  deler <- parameters$DefDesign$DelKolN
  deler <- names(deler)[deler %in% c(filtercols)]
  out <- list()
  
  for(del in deler){
    delkol <- parameters$DefDesign$DelKolN[del]
    delkolnames <- parameters$DefDesign$DelKols[[del]]
    delvalue <- unlist(strsplit(trimws(filters[[delkol]]), ","))
    delformat <- parameters$DefDesign$DelFormat[[del]]
    if(del == "A"){
      delvalue <- gsub("ALLE", paste0(fileinfo$amin, "_", fileinfo$amax), delvalue)
      delvalue <- gsub("^_(\\d+)", paste0(fileinfo$amin, "_\\1"), delvalue)
      delvalue <- gsub("(\\d+)_$", paste0("\\1_", fileinfo$amax), delvalue)
      delvalue <- gsub("^(\\d+)$", "\\1_\\1", delvalue)
      delvalue <- data.table::as.data.table(data.table::tstrsplit(delvalue, "_", type.convert = TRUE))
    } else {
      delvalue <- data.table::as.data.table(as.integer(delvalue))
    }
    out[[del]] <- data.table::setnames(delvalue, delkolnames)
  }
  return(out)
}

#' @title do_filfiltre_nykolsmerge
#' @description
#' Merges new columns to file according to the NYKOLSmerge column in table FILFILTRE
#' Only used in befvekst, together with YAlagVal
#' @keywords internal
#' @noRd
# do_filfiltre_nykolsmerge <- function(dt, filefilter){
#   
#   return(dt)
# }
