#' @title load_and_format_files
#' @description
#' Loads filegroups as specified in parameters$files
#' Adds FileDesign to parameter list after loading files
#' Teller file is loaded first, and other files are filtered according to years present in this file
#' Files are always loaded fresh into BUFFER, and overwritten if they already exist. 
#' @param parameters list of parameters generated by get_cubeparameters()
#' @return updated parameter list after loading and formatting files
load_and_format_files <- function(parameters){
  cat("\n* Laster og formatterer filgrupper\n")
  if(!exists("BUFFER", envir = .GlobalEnv)) .GlobalEnv$BUFFER <- list()
  tabfilter_tellerfile <- set_filter_tab(parameters$CUBEinformation)
  tellerfile <- parameters$files$TELLER
  isbuffer <- tellerfile %in% names(.GlobalEnv$BUFFER)
  if(isbuffer) BUFFER[[tellerfile]] <- NULL
  load_filegroup_to_buffer(filegroup = tellerfile, filter = tabfilter_tellerfile, parameters = parameters)
  
  nonteller_files <- unique(grep(paste0("^", tellerfile, "$"), parameters$files, invert = T, value = T))
  for (file in nonteller_files) {
    isbuffer <- file %in% names(BUFFER)
    if(isbuffer) BUFFER[[file]] <- NULL
    load_filegroup_to_buffer(filegroup = file, filter = NULL, parameters = parameters)
  }
  invisible(gc())
}

#' @title set_filter_tab
#' @description
#' Creates a filtering string based on the TABX and TABX_0 columns in table KUBER in ACCESS
#' If TABX_0 is provided, this is used for initial filtering of the filegroup, as these categories are needed during the data processing.
#' TABX is always used for final filtering of the cube.
#' @param cubeinformation information from table KUBER in ACCESS
#' @noRd
set_filter_tab <- function(cubeinformation){
  TabConds <- character()
  for (tab in names(cubeinformation)[grepl("^TAB\\d+$", names(cubeinformation))]) {
    istab <- !is.na(cubeinformation[[tab]]) && cubeinformation[[tab]] != ""
    if (istab) {
      tab0 <- paste0(tab, "_0")
      istab0 <- !is.null(cubeinformation[[tab0]]) && !is.na(cubeinformation[[tab0]]) && cubeinformation[[tab0]] != ""
      tablist <- cubeinformation[[tab]]
      if(istab0) tablist <- cubeinformation[[tab0]]
      isminus <- grepl("^-\\[", tablist)
      tablist <- gsub("^-\\[(.*)\\]$", "\\1", tablist)
      tablist <- paste0("\"", gsub(",", "\",\"", tablist), "\"")
      tabcond <- paste0("(", tab, " %in% c(", tablist, "))")
      if (isminus) tabcond <- paste0("!", tabcond)
      TabConds <- c(TabConds, tabcond)
    }
  } 
  tabfilter <- paste0(TabConds, collapse = " & ")
  if(tabfilter == "") tabfilter <- NULL
  return(tabfilter)
}

#' @title do_filter_columns
#' @description
#' Filters file according to filtering string, such as tabfilter generated by
#' @param file file to filter
#' @param filter filtering string
#' @noRd
do_filter_columns <- function(file, filter){
  file <- file[eval(rlang::parse_expr(filter))]
  return(file)
}

#' @title load_filegroup_to_buffer
#' @description
#' Loads the file into BUFFER in .GlobalEnv
#' The file is filtered using TABfilter and geoharmonized. 
#' If filefilter is defined, the file is formatted accordingly
#' @noRd
load_filegroup_to_buffer <- function(filegroup, filter = NULL, parameters){
  filefilter <- parameters$FILFILTRE[FILVERSJON == filegroup]
  isfilefilter <- nrow(filefilter) > 0
  alderfilter <- set_filter_age(parameters = parameters)
  yearfilter <- set_filter_year(parameters = parameters)
  filter <- paste0(c(filter, alderfilter, yearfilter), collapse = " & ")
  isfilter <- is_not_empty(filter)
  fileinfo <- parameters$fileinformation[[filegroup]]
  orgfile <- ifelse(isfilefilter, filefilter$ORGFIL, filegroup)
  
  FIL <- read_filegroup(orgfile)
  if(isfilter) FIL <- do_filter_columns(file = FIL, filter = filter)
 
  if(!isfilefilter){
    FIL <- do_harmonize_geo(file = FIL, vals = fileinfo$vals, rectangularize = FALSE, parameters = parameters)
    .GlobalEnv$BUFFER[[filegroup]] <- FIL
    return(invisible(NULL))
  } 
  
  if(isfilefilter){
    iskollapsdel <- grepl("\\S", filefilter$KOLLAPSdeler)
    if(iskollapsdel) FIL <- do_filfiltre_kollapsdeler(file = FIL, parts = filefilter$KOLLAPSdeler, parameters = parameters)
    
    isnyekolkolprerad <- grepl("\\S", filefilter$NYEKOL_KOL_preRAD)
    # TODO: optimalisere leggtilnyeverdikolonner
    if(isnyekolkolprerad) add_new_value_columns(dt = FIL, formulas = filefilter$NYEKOL_KOL_preRAD, post_moving_average = FALSE)
    
    # TODO: optimalisere finnredesign (find_redesign) og OmkodFil (recode_file)
    Filter <- set_recode_filter_filfiltre(fileinfo = fileinfo, parameters = parameters)
    if (length(Filter) > 0){
      prefilterdesign <- find_filedesign(FIL, parameters = parameters)
      redesign_filter <- FinnRedesign(prefilterdesign, list(Parts = Filter), parameters = parameters)
      FIL <- OmkodFil(FIL, redesign_filter, parameters = parameters)
    }
    
    isgeoharm <- filefilter$GEOHARM == 1
    if(isgeoharm){
      rectangularize <- ifelse(filefilter$REKTISER == 1, TRUE, FALSE)
      FIL <- do_harmonize_geo(file = FIL, vals = fileinfo$vals, rectangularize = rectangularize, parameters = parameters)
    }
    
    isnyekolrad <- grepl("\\S", filefilter$NYEKOL_RAD)
    if(isnyekolrad) FIL <- LeggTilSumFraRader(dt = FIL, NYdscr = filefilter$NYEKOL_RAD, FGP = fileinfo, parameters = parameters)
    
    isnykolsmerge <- grepl("\\S", filefilter$NYKOLSmerge)
    if(isnykolsmerge){
      NY <- eval(parse(text = filefilter$NYKOLSmerge))
      commoncols <- intersect(get_dimension_columns(names(NY)), get_dimension_columns(names(FIL)))
      FIL <- collapse::join(FIL, NY, on = commoncols, how = "l", overid = 2, verbose = 0)
    }
  }
  .GlobalEnv$BUFFER[[filegroup]] <- FIL
  return(invisible(NULL))
}

#' @title set_filter_year
#' @description
#' Sets age filter according to age groups set in ACCESS::KUBER, 
#' @noRd
set_filter_age <- function(parameters){
  isalder <- !is.na(parameters$CUBEinformation$ALDER) && parameters$CUBEinformation$ALDER != ""
  if(!isalder) return(NULL)
  
  accessalder <- unlist(strsplit(parameters$CUBEinformation$ALDER, ","))
  if(any(grepl("[^[:digit:]_]", accessalder))) return(NULL)
  
  aldersplit <- data.table::tstrsplit(accessalder, "_")
  amin <- ifelse(sum(is.na(aldersplit[[1]])) == 0,
                 min(as.numeric(aldersplit[[1]])),
                 getOption("khfunctions.amin"))
  amax <- ifelse(length(aldersplit) > 1 && sum(is.na(aldersplit[[2]])) == 0, 
                 max(as.numeric(aldersplit[[2]])),
                 getOption("khfunctions.amax"))
  
  if(is.na(amin) | is.na(amax)) stop("Feil i aldersfiltreringen, som leser fra ACCESS::KUBER::ALDER. Denne må være tom, 'ALLE', eller angi aldersgrupper separert med komma (X_Y, X_Y, X_Y).")
  return(paste0("ALDERl >= ", amin, " & ALDERh <= ", amax))
}

#' @title set_filter_year
#' @description Filters filegroups to remove years prior to AAR_START in ACCESS::KUBER
#' @keywords internal
#' @noRd
set_filter_year <- function(parameters){
  return(paste0("AARl >= ", parameters$CUBEinformation$AAR_START))
}


#' @title read_filegroup
#' @description Reads original filegroup. Will always read from "NYESTE" folder
#' @keywords internal
#' @noRd
#' @returns data.table
read_filegroup <- function(filegroup){
  file <- file.path(getOption("khfunctions.root"), getOption("khfunctions.filegroups.ny"), paste0(filegroup, ".rds"))
  if(!file.exists(file)) stop("Finner ikke filgruppe: ", file, "! Filgruppen må kjøres først.")
  DT <- data.table::setDT(readRDS(file))
  DT[, (names(.SD)) := NULL, .SDcols = names(DT)[names(DT) %in% c("KOBLID", "ROW")]]
  cat("\n** Lest inn fil: ", file)
  return(DT)
}

#' @title fetch_filegroup_from_buffer
#' @description
#' fetches filegroup already loaded into buffer. 
#' @keywords internal
#' @noRd
fetch_filegroup_from_buffer <- function(filegroup, parameters){
  if(exists("BUFFER", envir = .GlobalEnv) && filegroup %in% names(.GlobalEnv$BUFFER)){
    cat("\n** Henter FIL", filegroup, "fra BUFFER")
    return(data.table::copy(.GlobalEnv$BUFFER[[filegroup]]))
  }
  stop("Filgruppe ", filegroup, " ikke funnet i BUFFER")
}

#' @title do_harmonize_geo
#' @description
#' Harmonizes geographical codes
#' @noRd 
do_harmonize_geo <- function(file, vals = list(), rectangularize = TRUE, parameters) {
  geoomk <- parameters$KnrHarm
  georecode <- sum(collapse::funique(file$GEO) %in% geoomk$GEO)
  if(georecode > 0){
    cat("\n*** Recoding", georecode, "geo-codes")
    file <- collapse::join(file, geoomk, on = "GEO", how = "left", overid = 0, verbose = 0)
    file[!is.na(GEO_omk), let(GEO = GEO_omk)][, let(GEO_omk = NULL, HARMstd = NULL)]
  }
  if("FYLKE" %in% names(file)) file[, FYLKE := NULL]
  file <- do_aggregate_file(file = file, valsumbardef = vals)

  if(rectangularize){
    rectangularized <- data.table::data.table()
    design <- find_filedesign(file, parameters = parameters)
    
    for (Gn in design$Part[["Gn"]][["GEOniv"]]) {
      validgeo <- data.table::data.table(GEO = parameters$GeoKoder[GEOniv == Gn & FRA <= parameters$year & TIL > parameters$year]$GEO)
      designgeo <- design$Design[HAR == 1 & GEOniv == Gn, mget(intersect(names(file), names(design$Design)))]
      rectangularized <- data.table::rbindlist(list(expand.grid.dt(designgeo, validgeo), rectangularized))
    }
    file <- collapse::join(rectangularized, file, how = "l", overid = 0, verbose = 0)
    file <- set_implicit_null_after_merge(file, implicitnull_defs = vals)
  }
  
  file[, FYLKE := ifelse(GEOniv %in% c("H", "L"), "00", substr(GEO, 1, 2))]
  return(file)
}

#' @title do_aggregate_file
#' @description Aggregates file
#' @param file file to aggregate
#' @param valsumbardef list of value column definitions. Not summable values are removed. 
#' @noRd
do_aggregate_file <- function(file, valsumbardef = list()){
  if(!is(file, "data.table")) data.table::setDT(file)
  tabcols <- get_dimension_columns(names(file))
  valcols <- get_value_columns(names(file))
  colorder <- tabcols 
  for(val in valcols){
    file[is.na(get(val)) | get(val) == 0, paste0(val, ".a") := 0]
    colorder <- c(colorder, paste0(val, c("", ".f", ".a")))
  }
  if(!identical(data.table::key(file), tabcols)) data.table::setkeyv(file, tabcols)
  
  g <- collapse::GRP(file, tabcols)
  aggfile <- collapse::add_vars(g[["groups"]],
                                collapse::fsum(collapse::get_vars(file, valcols), g = g),
                                collapse::fmax(collapse::get_vars(file, paste0(valcols, ".f")), g = g),
                                collapse::fsum(collapse::get_vars(file, paste0(valcols, ".a")), g = g))
  
  for(val in valcols){
    if(val %in% names(valsumbardef) && valsumbardef[[val]]$sumbar == 0){
      valA <- paste0(val, ".a")
      valF <- paste0(val, ".f")
      aggfile[get(valA) > 1, c(val, valF) := list(NA, 2)]
    }
  }
  data.table::setcolorder(aggfile, colorder)
  return(aggfile)
}

#' @title do_filfiltre_kollapsdeler
#' @description 
#' collapses file according to the KOLLAPSdeler column in table FILFILTRE
#' @noRd
do_filfiltre_kollapsdeler <- function(file, parts, parameters){
  tabcols <- get_dimension_columns(names(file))
  parts <- unlist(strsplit(parts, ","))
  columns <- as.character(parameters$DefDesign$DelKolsF[parts])
  file[, (columns) := parameters$TotalKoder[parts]]
  cat(paste0("Kollapser kolonnene: ", paste0(columns, collapse = ", "), ". Før er dim "), dim(file))
  file <- file[, collapse::fsum(collapse::gby(.SD, tabcols))]
  cat(" og etter", dim(file), "\n")
  return(file)
}  

#' @title add_new_value_columns
#' @description adds new value columns from a set of formulas by reference
#' @param formulas Formula(s) to make new column(s), usually provided in ACCESS
#' @param post_moving_average if used after aggregating to moving average, additional columns should be generated.
#' @keywords internal
#' @noRd
add_new_value_columns <- function(dt, formulas, post_moving_average = FALSE){
  if(is_empty(formulas)) return(invisible(NULL))
  values <- get_value_columns(names(dt))
  formulas <- trimws(unlist(strsplit(formulas, ";")))
  for(f in formulas){
    name <-  gsub("^(.*?)=(.*)$", "\\1", f)
    formula <- gsub("^(.*?)=\\{(.*)\\}$", "\\2", f)
    included_columns <- character()
    for(col in values){
      if(grepl(col, formula)) included_columns <- c(included_columns, col)
    }
    dt[, (name) := eval(rlang::parse_expr(formula))]
    dt[, paste0(name, ".f") := do.call(pmax, c(.SD, list(na.rm = T))), .SDcols = paste0(included_columns, ".f")]
    dt[, paste0(name, ".a") := do.call(pmax, c(.SD, list(na.rm = T))), .SDcols = paste0(included_columns, ".a")]

    if(post_moving_average){
      dt[, (paste0(name, c(".n", ".fn1", ".fn3", ".fn9"))) := list(1,0,0,0)]
    }  
    dt[is.na(get(name)) | is.infinite(get(name)) | is.nan(get(name)), (paste0(name, c("", ".f"))) := list(NA, 2)]
  }
}

#' @title set_recode_filter_filfiltre
#' @description 
#' Uses information from FILFILTRE-columns GEONIV, ALDER, KJONN, UTDANN, LANDBAK, INNVKAT to further filter
#' a file version. This reduces file size by removing rows which is not needed. 
#' Years < KUBER:: AAR_START is already filtered out, and is therefore not included here. 
#' @keywords internal
#' @noRd
set_recode_filter_filfiltre <- function(fileinfo, parameters){
  filters <- parameters$FILFILTRE
  filtercols <- names(filters)[names(filters) %in% grep("^AAR$|^TAB\\d{1}$", parameters$DefDesign$DelKolN, value = T, invert = T)]
  filtercols <- filtercols[sapply(filters[, ..filtercols], function(col) is_not_empty(col))]
  deler <- parameters$DefDesign$DelKolN
  deler <- names(deler)[deler %in% c(filtercols)]
  out <- list()
  
  for(del in deler){
    delkol <- parameters$DefDesign$DelKolN[del]
    delkolnames <- parameters$DefDesign$DelKols[[del]]
    delvalue <- unlist(strsplit(trimws(filters[[delkol]]), ","))
    delformat <- parameters$DefDesign$DelFormat[[del]]
    if(del == "A"){
      delvalue <- gsub("ALLE", paste0(fileinfo$amin, "_", fileinfo$amax), delvalue)
      delvalue <- gsub("^_(\\d+)", paste0(fileinfo$amin, "_\\1"), delvalue)
      delvalue <- gsub("(\\d+)_$", paste0("\\1_", fileinfo$amax), delvalue)
      delvalue <- gsub("^(\\d+)$", "\\1_\\1", delvalue)
      delvalue <- data.table::as.data.table(data.table::tstrsplit(delvalue, "_", type.convert = TRUE))
    } else {
      delvalue <- data.table::as.data.table(as.integer(delvalue))
    }
    out[[del]] <- data.table::setnames(delvalue, delkolnames)
  }
  return(out)
}

#' @title OmkodFil (kb)
#' @noRd
OmkodFil <- function(FIL, RD, parameters) {
  orgkols <- names(FIL)
  data.table::setDT(FIL)
  tabnames <- get_dimension_columns(names(FIL))
  valkols <- get_value_columns(names(FIL))
  lp <- paste0(valkols, "=sum(", valkols, "),",
               valkols, ".f=max(", valkols, ".f),",
               valkols, ".a=sum(", valkols, ".a*(!is.na(", valkols, ") & ", valkols, "!=0))",
               collapse = ",")
  
  if (nrow(RD$FULL) > 0) {
    for (del in names(RD$Filters)) {
      data.table::setkeyv(FIL, names(RD$Filters[[del]]))
      data.table::setkeyv(RD$Filters[[del]], names(RD$Filters[[del]]))
      cat(" - Filtrerer ", del, ", dim før: ", dim(FIL), sep = "")
      if (any(duplicated(RD$Filters[[del]]))) {
        print("CARTESIAN????")
        print(RD$Filters[[del]])
        print(RD$Filters[[del]][duplicated(RD$Filters[[del]]), ])
      }
      FIL <- FIL[RD$Filters[[del]], nomatch = 0]
      cat(", og etter:", dim(FIL), "\n")
    }
    
    # NB! Rekkefoelge er essensiell, dvs at ubeting kommer til slutt
    beting <- intersect(parameters$DefDesign$AggPri[length(parameters$DefDesign$AggPri):1], c(parameters$DefDesign$BetingOmk, parameters$DefDesign$BetingF))
    ubeting <- intersect(parameters$DefDesign$AggPri[length(parameters$DefDesign$AggPri):1], c(parameters$DefDesign$UBeting))
    
    for (del in intersect(c(beting, ubeting), names(RD$KBs))) {
      orgtabs <- names(RD$KBs[[del]])[!grepl("_omk$", names(RD$KBs[[del]]))]
      omktabs <- names(RD$KBs[[del]])[grepl("_omk$", names(RD$KBs[[del]]))]
      bycols <- c(setdiff(tabnames, gsub("_omk", "", omktabs)), omktabs)
      
      # Sjekk type omkoding som trengs.
      # Dersom hver orgkode skal til mange omkkoder
      # er det uheldig aa merge FIL[KB] om FIL er stor siden det lages mange kopier av orglinjer i FIL
      # i slike tilfeller kobles i stedet inn en loop over omkoding til hver omktab  (jfr laging av tiaarssnitt i KREFT)
      
      data.table::setkeyv(RD$KBs[[del]], orgtabs)
      replikfaktor <- RD$KBs[[del]][, list(N = .N), by = orgtabs][, mean(N)]
      data.table::setkeyv(FIL, orgtabs)
      cat(" - Omkoder ", del, ", dim originalt er :", dim(FIL), sep = "")
      if (nrow(FIL) < 1000000 | replikfaktor < 4 | del == "Gn") {
        FIL <- FIL[RD$KBs[[del]], nomatch = 0, allow.cartesian = TRUE]
        # FIL<-FIL[RD$KBs[[del]],nomatch=0]
        cat(", etter merge:", dim(FIL))
        if (del == "Gn") {
          FIL[GEOniv_omk == "K", GEO := substr(GEO, 0, 4)]
          FIL[GEOniv_omk == "F", GEO := FYLKE]
          FIL[GEOniv_omk == "L", c("GEO", "FYLKE") := list("0", "00")]
          # FIL[GEOniv_omk == "B" & GEOniv == "S" & !grepl("^(0301|1103|1201|1601|4601|5001)", GEO), c("GEO", "FYLKE") := list("999999", "99")]
          FIL[GEOniv_omk=="B" & GEOniv=="S" & !GEO %in% parameters$GeoKoder[GEOniv=="B"]$GEO,c("GEO","FYLKE"):=list("999999","99")]
          FIL[GEOniv_omk == "H" & GEOniv != "H", GEO := plyr::mapvalues(FYLKE, parameters$HELSEREG$FYLKE, parameters$HELSEREG$HELSEREG, warn_missing = FALSE)]
          FIL[GEOniv_omk == "H", FYLKE := "00"]
        }
        data.table::setkeyv(FIL, bycols)
        lpl <- paste0("list(", lp, ")")
        FIL <- FIL[, eval(parse(text = lpl)), by = bycols]
        # Dette skulle vel vaert bedre, men blir alt for tregt? naar ikke bycols er key
        # FIL<-FIL[RD$KBs[[del]],nomatch=0,allow.cartesian=TRUE][, eval(parse(text=lp)), by=bycols]
      } else {
        KB <- data.table::copy(RD$KBs[[del]])
        data.table::setkeyv(KB, omktabs)
        OMKs <- unique(KB[, omktabs, with = FALSE])
        FILt <- FIL[0, ]
        for (i in 1:nrow(OMKs)) {
          OMK <- OMKs[i, ]
          print(OMK)
          KBt <- KB[OMK]
          data.table::setkeyv(KBt, orgtabs)
          FILd <- FIL[KBt, nomatch = 0, allow.cartesian = TRUE]
          data.table::setkeyv(FILd, bycols)
          lpt <- paste0("list(", paste(gsub("_omk$", "", names(OMK)), OMK, sep = "=", collapse = ","), ",", lp, ")")
          FILt <- rbind(FILt, FILd[, eval(parse(text = lpt)), by = bycols][, names(FILt), with = FALSE])
        }
        FIL <- FILt
      }
      cat(", og til slutt:", dim(FIL), "\n")
      data.table::setnames(FIL, names(FIL), gsub("_omk$", "", names(FIL)))
    }
  }
  
  if (nrow(RD$Udekk) > 0) {
    UDekk <- data.table::copy(RD$Udekk)
    restkols <- setdiff(tabnames, names(UDekk))
    data.table::setkeyv(FIL, names(UDekk))
    data.table::setkeyv(UDekk, names(UDekk))
    FIL <- FIL[!UDekk, ]
    valkolsF <- unlist(lapply(valkols, function(x) {
      paste0(x, c("", ".f", ".a"))
    }))
    UDekk[, (valkols) := NA]
    valg_f <- grep(".f$", valkolsF, value = TRUE)
    UDekk[, (valg_f) := 9]
    valg_a <- grep(".a$", valkolsF, value = TRUE)
    UDekk[, (valg_a) := 0]
    if (length(restkols) > 0) {
      rest <- as.data.frame(unique(FIL[, restkols, with = FALSE]))
      UDekk <- data.table::data.table(expand.grid.df(rest, as.data.frame(UDekk)))
    }
    FIL <- rbind(FIL[, orgkols, with = FALSE], UDekk[, orgkols, with = FALSE])
    cat("UDEKKA:", nrow(RD$Udekk), "\n")
    # print(subset(RD$Udekk,GEOniv!="B"))
    # print(RD$Udekk)
  }
  return(FIL)
}

#' @title LeggTilSumFraRader (kb)
#' Helper function in KlargjorFil and LagTNtabell
#' @keywords internal
#' @noRd
LeggTilSumFraRader <- function(dt, NYdscr, FGP = list(amin = 0, amax = 120), parameters) {
  if(is_empty(NYdscr)) return(dt)
  
  for (sumfra in unlist(stringr::str_split(NYdscr, ";"))) {
    sumfra <- trimws(sumfra)
    if(!grepl("^(.+?) *= *(.+?)\\{(.*)\\}$", sumfra)) stop("FEIL!!!!!: FILFILTRE::NYEKOL_RAD har feil format:", NYdscr, "\n")
    cat("\n*** Legger til kolonner som sum av rader: ", sumfra)
    nycol <- gsub("^ *(.+?) *= *(.+?)\\{(.*)\\} *$", "\\1", sumfra)
    gmlcol <- gsub("^ *(.+?) *= *(.+?)\\{(.*)\\} *$", "\\2", sumfra)
    expr <- gsub("^ *(.+?) *= *(.+?)\\{(.*)\\} *$", "\\3", sumfra)
    NF <- EkstraherRadSummer(dt = dt, pstrorg = expr, FGP = FGP, parameters = parameters)
    gmlcols <- paste0(gmlcol, c("", ".f", ".a"))
    nycols <- paste0(nycol, c("", ".f", ".a"))
    data.table::setnames(NF, gmlcols, nycols)
    commontabs <- intersect(get_dimension_columns(names(dt)), get_dimension_columns(names(NF)))
    
    dt <- collapse::join(dt, NF, on = commontabs, how = "l", overid = 2, verbose = 0)
    dt <- set_implicit_null_after_merge(file = dt, list(gmlcol = FGP$vals, nycol = FGP$vals[gmlcol]))
    }
  return(dt)
}

#' @title EkstraherRadSummer (kb) 
#' @keywords internal
#' @noRd
EkstraherRadSummer <- function(dt, pstrorg, FGP = list(amin = 0, amax = 120), parameters) {
  dt <- data.table::copy(dt)
  amin <- FGP$amin
  amax <- FGP$amax
  
  pstrorg <- gsub("(?<!=)=(?!=)", "==", pstrorg, perl = TRUE)
  pstrorg <- gsub(" *== *(?=c\\()", " %in% ", pstrorg, perl = TRUE)
  
  pstrorg <- gsub("(^ *|& *)ALDER( *&| *$)", "ALDER==\\1\"ALLE\"\\2", pstrorg)
  pstrorg <- gsub("(^ *|& *)(KJONN|UTD|LAND|INNVKAT)( *&| *$)", "\\1\\2==0\\3", pstrorg)
  
  # Er det mulig aa abstrahere her, dvs aa ta alle "INT"-deler med samme syntaks???
  pstrorg <- gsub("ALDER *(={1,2}) *\"*ALLE\"*", paste0("ALDERl==", amin, " & ALDERh==", amax), pstrorg)
  pstrorg <- gsub("ALDER *(={1,2}) *(\\d+)$", "ALDERl==\\2 & ALDERh==\\2", pstrorg)
  pstrorg <- gsub("AAR *(={1,2}) *(\\d+)$", "AARl==\\2 & AARh==\\2", pstrorg)
  
  alletabs <- stringr::str_replace(unlist(stringr::str_split(pstrorg, " *& *")), "^(\\w*?) *(%in%.*|==.*| *$)", "\\1")
  
  # Fjern de som ikke er del av subset betingelse
  subsetstr <- gsub("^ *\\w+ *(&|$)|(^|&) *\\w+ *$", "", pstrorg, perl = TRUE)
  subsetstr <- gsub("& *\\w+ *&", "&", subsetstr, perl = TRUE)
  
  # Splitt i kolonnenavn og verdi
  subtabs <- stringr::str_replace(unlist(stringr::str_split(subsetstr, " *& *")), "^(\\w+) *(%in%.*|==.*)", "\\1")
  subvals <- stringr::str_replace(unlist(stringr::str_split(subsetstr, " *& *")), "^.*(%in% *|== *)(\\w+)", "\\2")
  subvals <- setNames(subvals, subtabs)
  # Filtrer til de som er aktuelle for omkoding
  subvals <- subvals[names(subvals) %in% parameters$DefDesign$DesignKols]
  
  # Omkod disse
  if (length(subvals) > 0) {
    # For omkodbare kolonner maa disse omkodes til soekte verdier (for generalitet maa det omkodes selv om disse finnes)
    OmkParts <- list()
    for (del in names(parameters$DefDesign$DelKols)) {
      if (all(parameters$DefDesign$DelKols[[del]] %in% names(subvals))) {
        dvals <- subvals[parameters$DefDesign$DelKols[[del]]]
        if (parameters$DefDesign$DelFormat[[del]] == "integer") {
          dvals <- setNames(as.integer(dvals), names(dvals))
        }
        OmkParts[[del]] <- setNames(data.frame(matrix(dvals, ncol = length(dvals))), names(dvals))
      } else if (any(parameters$DefDesign$DelKols[[del]] %in% names(subvals))) {
        print("VARSKU HER!!!!!!!!!!!!!!! FEIL i EkstraherRadSummer!")
      }
    }
    print("Til OmkodFil fra EkstraherRadSummer, dette kan fort gi udekt ved ubalansert design. Dette faller bort igjen ved NF[TNF")
    # dt <- OmkodFil(dt, FinnRedesign(FinnDesign(dt, parameters = parameters), list(Parts = OmkParts), parameters = parameters), parameters = parameters)
    design <- find_filedesign(dt, parameters = parameters)
    redesign <- FinnRedesign(design, list(Parts = OmkParts), parameters = parameters)
    dt <- OmkodFil(dt, redesign, parameters = parameters)
  }
  if(subsetstr != "") dt <- eval(parse(text = paste0("subset(dt,", subsetstr, ")"))) # BYTTE MED do_filter_columns????
  dt <- do_aggregate_file(dt[, .SD, .SDcols = names(dt)[!names(dt) %in% alletabs]])
  return(dt)
}

#' @title do_filfiltre_nykolsmerge
#' @description
#' Merges new columns to file according to the NYKOLSmerge column in table FILFILTRE
#' Only used in befvekst, together with YAlagVal
#' @keywords internal
#' @noRd
# do_filfiltre_nykolsmerge <- function(dt, filefilter){
#   
#   return(dt)
# }

#' @title YAlagVal (kb)
#' @description 
#' used in access, only for befvekst. AGE lag is not used, only year. 
#' Generate a new file with all dimension columns and the selected value column. 
#' AARl and ALDERl is changed by the factors specified in YL and AL, to be merged onto different rows. 
#' 
#' This function can probably be replaced by collapse-functions flag/flead. 
#' @param FG file
#' @param YL year lag
#' @param AL age lag
#' @param vals value to create lag value
#' @keywords internal
#' @noRd
YAlagVal <- function(FG, YL, AL, vals = get_value_columns(names(FG))) {
  ltag <- function(lag) {
    ltag <- ""
    if (lag > 0) {
      ltag <- paste("m", abs(lag), sep = "")
    } else if (lag < 0) {
      ltag <- paste("p", abs(lag), sep = "")
    }
    return(ltag)
  }
  FGl <- data.table::copy(FG)
  FGl[, c("lAARl", "lALDERl") := list(AARl + YL, ALDERl + AL)]
  FGl[, c("AARl", "AARh", "ALDERl", "ALDERh") := list(NULL)]
  data.table::setnames(FGl, c("lAARl", "lALDERl"), c("AARl", "ALDERl"))
  tabkols <- setdiff(names(FGl), get_value_columns(names(FG), full = TRUE))
  lvals <- paste("Y", ltag(YL), "_A", ltag(AL), "_", vals, c("", ".f", ".a"), sep = "")
  data.table::setnames(FGl, unlist(lapply(vals, function(x) {
    paste(x, c("", ".f", ".a"), sep = "")
  })), lvals)
  FGl <- FGl[, c(tabkols, lvals), with = FALSE]
  data.table::setkeyv(FG, tabkols)
  data.table::setkeyv(FGl, tabkols)
  return(FGl)
}

#' @title set_lead_value
#' 
#' @description
#' CAN REPLACE YALAGVAL, BUT MUST FIND A WAY OF USING IT IN ACCESS
#' MAKE NEW COLUMN "LAGVAL" 
#' @keywords internal
#' @noRd
set_lead_value <- function(file, yearlag = -1, vals = NULL){
  if(is.null(vals)) stop("vals must be specified to generate lead values")
  d <- data.table::copy(file)
  d[, lagAARl := AARl + yearlag]
  d[, c("AARl", "AARh") := list(NULL)]
  data.table::setnames(d, "lagAARl", "AARl")
  tabcols <- get_dimension_columns(names(d))
  # m/p means plus/minus
  lagprefix <- paste0("Y", ifelse(yearlag < 0, "p", "m"), abs(yearlag), "_A_") 
  oldvals <- paste0(rep(vals, each = 3), c("", ".f", ".a"))
  newvals <- paste0(lagprefix, allvals)
  data.table::setnames(d, old = allvals, new = newvals)
  d <- d[, mget(c(tabcols, newvals))]
  return(d)
}
