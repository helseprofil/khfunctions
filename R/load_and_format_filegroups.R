#' @title load_and_format_filegroups
#' @description
#' Loads filegroups as specified in parameters$files
#' Adds FileDesign to parameter list after loading files
#' Formatted files are stored in the global environment, in the BUFFER list. 
#' @param parameters list of parameters generated by [get_cubeparameters()]
#' @return updated parameter list after loading and formatting files
load_and_format_files <- function(parameters, batchdate, versjonert, globs){
  if(!exists("BUFFER", envir = .GlobalEnv)) .GlobalEnv$BUFFER <- list()
  tabfilter_tellerfil <- set_tabfilter(parameters$CUBEinformation)
  
  for (file in unique(parameters$files)) {
    isbuffer <- file %in% names(BUFFER)
    tabfilter <- ifelse(file == parameters$files$TELLER, tabfilter_tellerfil, "")
    if(!isbuffer) load_filegroup_to_buffer(filegroup = file, tabfilter = tabfilter, parameters = parameters, versjonert = versjonert)
    invisible(gc())
  }
}

#' @title set_tabfilter
#' @description
#' Creates a filtering string based on the TABX and TABX_0 columns in table KUBER in ACCESS
#' @noRd
#' @param cubeinformation read from talbe KUBER in ACCESS
set_tabfilter <- function(cubeinformation){
  TabConds <- character()
  for (tab in names(cubeinformation)[grepl("^TAB\\d+$", names(cubeinformation))]) {
    istab <- !is.na(cubeinformation[[tab]]) && cubeinformation[[tab]] != ""
    if (istab) {
      tab0 <- paste0(tab, "_0")
      istab0 <- !is.null(cubeinformation[[tab0]]) && !is.na(cubeinformation[[tab0]]) && cubeinformation[[tab0]] != ""
      tablist <- cubeinformation[[tab]]
      if (istab0) tablist <- cubeinformation[[tab0]]
      isminus <- grepl("^-\\[", tablist)
      tablist <- gsub("^-\\[(.*)\\]$", "\\1", tablist)
      tablist <- paste0("\"", gsub(",", "\",\"", tablist), "\"")
      tabcond <- paste0("(", tab, " %in% c(", tablist, "))")
      if (isminus) tabcond <- paste0("!", tabcond)
      TabConds <- c(TabConds, tabcond)
    }
  } 
  tabfilter <- paste0(TabConds, collapse = " & ")
  return(tabfilter)
}

#' @title do_tabfilter
#' @description
#' Filters file according to tabfilter set by [set_tabfilter()]
#' @noRD
#' @param file file to filter
#' @param tabfilter filtering string created by [set_tabfilter()]
do_tabfilter <- function(file, tabfilter){
  cat("Filtrer med tab-filter, før er dim", dim(file))
  file <- file[eval(rlang::parse_expr(tabfilter))]
  cat(" og etter", dim(file), "\n")
  return(file)
}

#' @title load_filegroup_to_buffer
#' @description
#' Loads the file into BUFFER in .GlobalEnv
#' The file is filtered using TABfilter and geoharmonized. 
#' If filefilter is defined, the file is formatted accordingly
#' @noRd
#' @param filegroup 
#' @param tabfilter 
#' @param filefilter 
load_filegroup_to_buffer <- function(filegroup, filename, tabfilter, parameters, versjonert){
  
  filefilter <- parameters$FILFILTRE[FILVERSJON == filegroup]
  isfilefilter <- nrow(filefilter) > 0
  istabfilter <- tabfilter != ""
  fileinfo <- parameters$fileinformation[[filegroup]]
  orgfile <- ifelse(isfilefilter, filefilter$ORGFIL, filegroup)
  
  FIL <- FinnFil(orgfile, versjonert = versjonert, globs = globs)$FT
  if(istabfilter) FIL <- do_tabfilter(file = FIL, tabfilter = tabfilter)
 
  if(!isfilefilter){
    FIL <- do_harmonize_geo(file = FIL, vals = filegroupinformation$vals, rectangularize = FALSE, globs = globs)
    .GlobalEnv$BUFFER[[filegroup]] <- FIL
    return(invisible(NULL))
  } 
  
  if(isfilefilter){
    iskollapsdel <- grepl("\\S", filefilter$KOLLAPSdeler)
    if(iskollapsdel) FIL <- do_filfiltre_kollapsdeler(file = FIL, parts = filefilter$KOLLAPSdeler, globs = globs)
    
    isnyekolkolprerad <- grepl("\\S", filefilter$NYEKOL_KOL_preRAD)
    # TODO: optimalisere leggtilnyeverdikolonner
    if(isnyekolkolprerad) FIL <- LeggTilNyeVerdiKolonner(FIL, filefilter$NYEKOL_KOL_preRAD, slettInf = TRUE)
    
    Filter <- SettFilterDesign(filefilter, bruk0 = FALSE, FGP = fileinfo, globs = globs)
    # TODO: optimalisere leggtilnyeverdikolonner
    if (length(Filter) > 0) FIL <- OmkodFil(FIL, FinnRedesign(FinnDesign(FIL, globs = globs), list(Parts = Filter), globs = globs), globs = globs)
    
    isgeoharm <- filefilter$GEOHARM == 1
    if(isgeoharm){
      rectangularize <- ifelse(filefilter$REKTISER == 1, TRUE, FALSE)
      FIL <- do_harmonize_geo(file = FIL, vals = fileinfo$vals, rectangularize = rectangularize, globs = globs)
    }
    
    # INAKTIV, FJERNE FRA ACCESS?
    # isnyetab <- grepl("\\S", filefilter$NYETAB)
    # if(isnyetab) FIL <- AggregerRader(FIL, filefilter$NYETAB, FGP = FGP)
    
    isnyekolrad <- grepl("\\S", filefilter$NYEKOL_RAD)
    if(isnyekolrad) FIL <- LeggTilSumFraRader(FIL, filefilter$NYEKOL_RAD, FGP = FGP, globs = globs)
    
    # INAKTIV, FJERNE FRA ACCESS?
    # isnyekolkol <- grepl("\\S", filefilter$NYEKOL_KOL)
    # if(isnyekolkol) FIL <- LeggTilNyeVerdiKolonner(FIL, filefilter$NYEKOL_KOL, slettInf = TRUE)
    
    isnykolsmerge <- grepl("\\S", filefilter$NYKOLSmerge)
    if(isnykolsmerge){
      # FIL <- do_filfiltre_nykolsmerge(file = FIL, filefilter = filefilter)
      # cat("\nFILFILTRE:NYKOLSmerge\n")
      # NY <- eval(parse(text = filefilter$NYKOLSmerge))
      # tabK <- intersect(get_dimension_columns(names(NY)), get_dimension_columns(names(FIL)))
      # data.table::setkeyv(NY, tabK)
      # data.table::setkeyv(FIL, tabK)
      # FIL <- NY[FIL]
    }
    
    isrsynt1 <- grepl("\\S", filefilter$FF_RSYNT1)
    if(isrsynt1){
      filefilter$FF_RSYNT1 <- gsub("\\\r", "\\\n", filefilter$FF_RSYNT1)
      rsynterr <- try(eval(parse(text = filefilter$FF_RSYNT1)), silent = TRUE)
      if ("try-error" %in% class(rsynt1err)) {
        print(rsynterr)
        stop("Something went wrong in R, RSYNT1")
      }
    }
    .GlobalEnv$BUFFER[[filegroup]] <- FIL
    return(invisible(NULL))
  }
}

#' @title do_harmonize_geo
#' @description
#' Harmonizes geographical codes
#' @noRD
#' @param file 
#' @param vals 
#' @param rectangularize 
#' @param globs 
do_harmonize_geo <- function(file, vals = list(), rectangularize = TRUE, globs = SettGlobs()) {
  GEOstdAAR = getOption("khfunctions.year")
  geoomk <- globs$KnrHarm
  if(any(collapse::funique(file$GEO) %in% geoomk$GEO)){
    file <- collapse::join(file, geoomk, on = "GEO", how = "left", overid = 0, verbose = 0)
    file[!is.na(GEO_omk), let(GEO = GEO_omk)][, let(GEO_omk = NULL, HARMstd = NULL)]
  }
  if("FYLKE" %in% names(file)) collapse::settransform(file, FYLKE = NULL)
  
  file <- do_aggregate_file(file = file, valsumbardef = vals, globs = globs)

  if(rectangularize){
    rectangularized <- data.table::data.table()
    design <- FinnDesign(file, globs = globs)
    
    for (Gn in design$Part[["Gn"]][["GEOniv"]]) {
      validgeo <- data.table::data.table(GEO = globs$GeoKoder[GEOniv == Gn & FRA <= getOption("khfunctions.year") & TIL > getOption("khfunctions.year")]$GEO)
      designgeo <- design$Design[HAR == 1 & GEOniv == Gn, mget(intersect(names(file), names(design$Design)))]
      rectangularized <- data.table::rbindlist(list(expand.grid.dt(designgeo, validgeo), 
                                                    rectangularized))
    }
    file <- collapse::join(rectangularized, file, how = "l", overid = 0, verbose = 0)
    file <- set_implicit_null_after_merge(file, implicitnull_defs = vals)
  }
  
  file[, FYLKE := ifelse(GEOniv %in% c("H", "L"), "00", substr(GEO, 1, 2))]
  return(file)
}

#' @title set_implicit_null_after_merge (kb)
#' @description
#' Fixing implicit 0 occurring after merging, using information from VALXmiss in access. 
#' Previous name SettMergeNAs
#' @param file
#' @param implicitnull_defs 
set_implicit_null_after_merge <- function(file, implicitnull_defs = list()) {
  
  vals <- get_value_columns(names(file))
  
  for (val in vals) {
    if (val %in% names(implicitnull_defs)) {
      VALmiss <- implicitnull_defs[[val]]$miss
      replacemissing <- list()
      if(VALmiss == "..") replacemissing <- list(0, 1, 1)
      if(VALmiss == ".") replacemissing <- list(0, 2, 1)
      if(VALmiss == ":") replacemissing <- list(0, 3, 1)
      if(!grepl("\\D", VALmiss)) replacemissing <- list(as.numeric(VALmiss), 0, 1)
      if(length(replacemissing) == 0) stop(val, " listed in VALXnavn, but VALXmiss is not '..', '.', ':', or numeric")
    } else {
      replacemissing <- list(0, 0, 1)
    }
    
    valF <- paste0(val, ".f")
    valA <- paste0(val, ".a")
    missingrows <- which((is.na(file[[val]]) & file[[valF]] == 0) | is.na(file[[valF]]))
    n_missing <- length(missingrows)
    if(n_missing > 0) cat("Implisitte nuller: Setter", val, "=", replacemissing[[1]], "and", valF, "=", replacemissing[[2]], "for",  n_missing, "rader\n")
    file[missingrows, names(.SD) := replacemissing, .SDcols = c(val, valF, valA)]
  }
  return(file)
}

#' @title do_filfiltre_kollapsdeler
#' @description 
#' collapses file according to the KOLLAPSdeler column in table FILFILTRE
#' @noRD
#' @param file 
#' @param parts 
#' @param globs 
do_filfiltre_kollapsdeler <- function(file, parts, globs){
  tabcols <- get_dimension_columns(names(file))
  parts <- unlist(strsplit(parts, ","))
  columns <- as.character(globs$DefDesign$DelKolsF[parts])
  file[, (columns) := globs$TotalKoder[parts]]
  cat(paste0("Kollapser kolonnene: ", paste0(columns, collapse = ", "), ". Før er dim "), dim(file))
  file <- file[, collapse::fsum(collapse::gby(.SD, tabcols))]
  cat(" og etter", dim(file), "\n")
  return(file)
}  

#' LeggTilNyeVerdiKolonner (kb)
#' # FIKS DENNE
#'
#' @param TNF 
#' @param NYEdscr 
#' @param slettInf 
#' @param postMA 
LeggTilNyeVerdiKolonner <- function(TNF, NYEdscr, slettInf = TRUE, postMA = FALSE) {
  is_kh_debug()
  
  TNF <- data.table::copy(TNF) # Faar uoensket warning om self.reference under om ikke gjoer slik
  data.table::setDT(TNF)
  valKols <- gsub("^(.+)\\.f$", "\\1", names(TNF)[grepl(".+\\.f$", names(TNF))])
  # get_value_columns(names(TNF))
  if (!(is.na(NYEdscr) | NYEdscr == "")) {
    for (nycolexpr in unlist(stringr::str_split(NYEdscr, ";"))) {
      nycol <- gsub("^(.*?)=(.*)$", "\\1", nycolexpr)
      expr <- gsub("^(.*?)=(.*)$", "\\2", nycolexpr)
      invKols <- valKols[sapply(valKols, FUN = function(x) {
        grepl(x, expr)
      })]
      eval(parse(text = paste(
        "TNF[,c(\"", paste(nycol, c("", ".f", ".a"), collapse = "\",\"", sep = ""), "\")
      :=list(", expr, ",pmax(", paste(invKols, ".f", collapse = ",", sep = ""), "),
                      pmax(", paste(invKols, ".a", collapse = ",", sep = ""), "))]",
        sep = ""
      )))
      if (postMA == TRUE) {
        eval(parse(text = paste(
          "TNF[,c(\"", paste(nycol, c(".n", ".fn1", ".fn3", ".fn9"), collapse = "\",\"", sep = ""), "\")
        :=list(1,0,0,0)]",
          sep = ""
        )))
      }
      if (slettInf == TRUE) {
        eval(parse(text = paste("suppressWarnings(",
                                "TNF[", nycol, "%in% c(Inf,NaN,NA),c(\"", paste(nycol, c("", ".f"), collapse = "\",\"", sep = ""), "\"):=list(NA,2)])",
                                sep = ""
        )))
      }
    }
  }
  return(TNF)
}

#' OmkodFil (kb)
#'
#' @param FIL 
#' @param RD 
#' @param globs 
OmkodFil <- function(FIL, RD, globs = SettGlobs()) {
  is_kh_debug()
  
  orgkols <- names(FIL)
  data.table::setDT(FIL)
  tabnames <- get_dimension_columns(names(FIL))
  valkols <- get_value_columns(names(FIL))
  lp <- paste0(valkols, "=sum(", valkols, "),",
               valkols, ".f=max(", valkols, ".f),",
               valkols, ".a=sum(", valkols, ".a*(!is.na(", valkols, ") & ", valkols, "!=0))",
               collapse = ",")
  
  if (nrow(RD$FULL) > 0) {
    for (del in names(RD$Filters)) {
      data.table::setkeyv(FIL, names(RD$Filters[[del]]))
      data.table::setkeyv(RD$Filters[[del]], names(RD$Filters[[del]]))
      cat("Filtrerer", del, "foer dim(FIL)=", dim(FIL))
      if (any(duplicated(RD$Filters[[del]]))) {
        print("CARTESIAN????")
        print(RD$Filters[[del]])
        print(RD$Filters[[del]][duplicated(RD$Filters[[del]]), ])
      }
      FIL <- FIL[RD$Filters[[del]], nomatch = 0]
      cat(" og etter", dim(FIL), "\n")
    }
    
    # NB! Rekkefoelge er essensiell, dvs at ubeting kommer til slutt
    beting <- intersect(globs$DefDesign$AggPri[length(globs$DefDesign$AggPri):1], c(globs$DefDesign$BetingOmk, globs$DefDesign$BetingF))
    ubeting <- intersect(globs$DefDesign$AggPri[length(globs$DefDesign$AggPri):1], c(globs$DefDesign$UBeting))
    
    for (del in intersect(c(beting, ubeting), names(RD$KBs))) {
      orgtabs <- names(RD$KBs[[del]])[!grepl("_omk$", names(RD$KBs[[del]]))]
      omktabs <- names(RD$KBs[[del]])[grepl("_omk$", names(RD$KBs[[del]]))]
      bycols <- c(setdiff(tabnames, gsub("_omk", "", omktabs)), omktabs)
      
      # Sjekk type omkoding som trengs.
      # Dersom hver orgkode skal til mange omkkoder
      # er det uheldig aa merge FIL[KB] om FIL er stor siden det lages mange kopier av orglinjer i FIL
      # i slike tilfeller kobles i stedet inn en loop over omkoding til hver omktab  (jfr laging av tiaarssnitt i KREFT)
      
      data.table::setkeyv(RD$KBs[[del]], orgtabs)
      replikfaktor <- RD$KBs[[del]][, list(N = .N), by = orgtabs][, mean(N)]
      data.table::setkeyv(FIL, orgtabs)
      cat("Omkoder", del, "dim(FIL) er ", dim(FIL), "originalt")
      if (nrow(FIL) < 1000000 | replikfaktor < 4 | del == "Gn") {
        FIL <- FIL[RD$KBs[[del]], nomatch = 0, allow.cartesian = TRUE]
        # FIL<-FIL[RD$KBs[[del]],nomatch=0]
        cat(" og", dim(FIL), "etter merge")
        if (del == "Gn") {
          FIL[GEOniv_omk == "K", GEO := substr(GEO, 0, 4)]
          FIL[GEOniv_omk == "F", GEO := FYLKE]
          FIL[GEOniv_omk == "L", c("GEO", "FYLKE") := list("0", "00")]
          FIL[GEOniv_omk == "B" & GEOniv == "S" & !grepl("^(0301|1103|1201|1601|4601|5001)", GEO), c("GEO", "FYLKE") := list("999999", "99")]
          # Dette er daarlig, boer endre til
          # FIL[GEOniv_omk=="B" & GEOniv=="S" & !GEO %in% globs$GeoKoder[GEOniv=="B"]$GEO,c("GEO","FYLKE"):=list("999999","99")]
          FIL[GEOniv_omk == "H" & GEOniv != "H", GEO := plyr::mapvalues(FYLKE, globs$HELSEREG$FYLKE, globs$HELSEREG$HELSEREG, warn_missing = FALSE)]
          FIL[GEOniv_omk == "H", FYLKE := "00"]
        }
        data.table::setkeyv(FIL, bycols)
        lpl <- paste0("list(", lp, ")")
        FIL <- FIL[, eval(parse(text = lpl)), by = bycols]
        # Dette skulle vel vaert bedre, men blir alt for tregt? naar ikke bycols er key
        # FIL<-FIL[RD$KBs[[del]],nomatch=0,allow.cartesian=TRUE][, eval(parse(text=lp)), by=bycols]
      } else {
        KB <- data.table::copy(RD$KBs[[del]])
        data.table::setkeyv(KB, omktabs)
        OMKs <- unique(KB[, omktabs, with = FALSE])
        FILt <- FIL[0, ]
        for (i in 1:nrow(OMKs)) {
          OMK <- OMKs[i, ]
          print(OMK)
          KBt <- KB[OMK]
          data.table::setkeyv(KBt, orgtabs)
          FILd <- FIL[KBt, nomatch = 0, allow.cartesian = TRUE]
          data.table::setkeyv(FILd, bycols)
          lpt <- paste0("list(", paste(gsub("_omk$", "", names(OMK)), OMK, sep = "=", collapse = ","), ",", lp, ")")
          FILt <- rbind(FILt, FILd[, eval(parse(text = lpt)), by = bycols][, names(FILt), with = FALSE])
        }
        FIL <- FILt
      }
      cat(" og til slutt", dim(FIL), "\n")
      data.table::setnames(FIL, names(FIL), gsub("_omk$", "", names(FIL)))
    }
  }
  
  if (nrow(RD$Udekk) > 0) {
    UDekk <- data.table::copy(RD$Udekk)
    restkols <- setdiff(tabnames, names(UDekk))
    data.table::setkeyv(FIL, names(UDekk))
    data.table::setkeyv(UDekk, names(UDekk))
    FIL <- FIL[!UDekk, ]
    valkolsF <- unlist(lapply(valkols, function(x) {
      paste0(x, c("", ".f", ".a"))
    }))
    ## feil med recycling av := lest NEWS 1.12.2 data.table
    ## UDekk[,(valkolsF):=list(NA,9,0)]
    UDekk[, (valkols) := NA]
    valg_f <- grep(".f$", valkolsF, value = TRUE)
    UDekk[, (valg_f) := 9]
    valg_a <- grep(".a$", valkolsF, value = TRUE)
    UDekk[, (valg_a) := 0]
    if (length(restkols) > 0) {
      rest <- as.data.frame(unique(FIL[, restkols, with = FALSE]))
      UDekk <- data.table::data.table(expand.grid.df(rest, as.data.frame(UDekk)))
    }
    FIL <- rbind(FIL[, orgkols, with = FALSE], UDekk[, orgkols, with = FALSE])
    cat("UDEKKA:", nrow(RD$Udekk), "\n")
    # print(subset(RD$Udekk,GEOniv!="B"))
    print(RD$Udekk)
  }
  return(FIL)
}

#' LeggTilSumFraRader (kb)
#'
#' Helper function in KlargjorFil and LagTNtabell
#' @param TNF 
#' @param NYdscr 
#' @param FGP 
#' @param globs 
LeggTilSumFraRader <- function(TNF, NYdscr, FGP = list(amin = 0, amax = 120), globs = SettGlobs()) {
  is_kh_debug()
  
  if (!(is.na(NYdscr) | NYdscr == "")) {
    for (sumfra in unlist(stringr::str_split(NYdscr, ";"))) {
      # cat("SUMFRA: ",sumfra,"\n")
      if (grepl("^ *(.+?) *= *(.+?)\\{(.*)\\} *$", sumfra)) {
        nycol <- gsub("^ *(.+?) *= *(.+?)\\{(.*)\\} *$", "\\1", sumfra)
        gmlcol <- gsub("^ *(.+?) *= *(.+?)\\{(.*)\\} *$", "\\2", sumfra)
        expr <- gsub("^ *(.+?) *= *(.+?)\\{(.*)\\} *$", "\\3", sumfra)
        # cat("nycol:",nycol,"gmlcol:",gmlcol,"expr:",expr,"\n")
        NF <- EkstraherRadSummer(TNF, expr, FGP = FGP, globs = globs)
        gmlcols <- paste0(gmlcol, c("", ".f", ".a"))
        nycols <- paste0(nycol, c("", ".f", ".a"))
        data.table::setnames(NF, gmlcols, nycols)
        # print(NF)
        # Sy sammen
        commontabs <- globs$DefDesign$DesignKolsFA[globs$DefDesign$DesignKolsFA %in% names(NF)]
        
        # Er usikker paa om hva som egentlig er best her.
        # Siden OmkodFraPart brukt i EkstraherRadSummer gir full rektulangusering kan man ha satt
        # deler i NF som er udekket i TNF. 1) Disse oenskes vel egentlig ikke med
        # men motsatt, 2) dersom TNF ha manglende GEO-koder som finnes i NF er det kanskje oenskelig aa ha disse med
        # Jeg velger aa sette venstre join TNF->NF slik at problem 1 faller bort
        # Saa lenge hervaerende prosedyre bare kjoeres etter at TNF er rektangularisert mht GEO faller ogsaa 2) bort
        # Dette gjelder i standard produskjonsloeype (LagTnTabell, LagKUBE etc)
        
        setkeym(TNF, commontabs)
        setkeym(NF, commontabs)
        dimorg <- dim(TNF)
        TNF <- NF[, c(commontabs, nycols), with = FALSE][TNF]
        cat("LeggTilSumFraRader. Foer er dim(TNF)", dimorg, "og dim(NF)", dim(NF), "etter er dim(TNF)", dim(TNF), "\n")
        # altsaa ikke
        # TNF<-merge(TNF,NF[,c(commontabs,nycols),with=FALSE],all=TRUE,by=commontabs)
        
        # TNF<-merge(TNF,NF[,c(commontabs,nycols),with=FALSE],all=TRUE,by=commontabs)
        TNF <- set_implicit_null_after_merge(TNF, list(gmlcol = FGP$vals, nycol = FGP$vals[gmlcol]))
        
        # print(TNF)
      } else {
        cat("FEIL!!!!!: NYEKOL_RAD har feil format:", NYdscr, "\n")
      }
    }
  }
  
  return(TNF)
}

#' @title do_filfiltre_nykolsmerge
#' @description
#' Merges new columns to file according to the NYKOLSmerge column in table FILFILTRE
#' @noRD
#' @param file 
do_filfiltre_nykolsmerge <- function(file, filefilter){
  #   NY <- eval(parse(text = filter$NYKOLSmerge))
  #   tabK <- intersect(get_dimension_columns(names(NY)), get_dimension_columns(names(FIL)))
  #   data.table::setkeyv(NY, tabK)
  #   data.table::setkeyv(FIL, tabK)
  #   FIL <- NY[FIL]
  # }
}

#' @Title YAlagVal (kb)
#' used in access, only for befvekst. AGE lag is not used, only year. 
#' 
#' Generate a new file with all dimension columns and the selected value column. 
#' AARl and ALDERl is changed by the factors specified in YL and AL, to be merged onto different rows. 
#' 
#' This function can probably be replaced by collapse-functions flag/flead. 
#' @param FG file
#' @param YL year lag
#' @param AL age lag
#' @param vals value to create lag value
#' @param globs global parameters
YAlagVal <- function(FG, YL, AL, vals = get_value_columns(names(FG))) {
  ltag <- function(lag) {
    ltag <- ""
    if (lag > 0) {
      ltag <- paste("m", abs(lag), sep = "")
    } else if (lag < 0) {
      ltag <- paste("p", abs(lag), sep = "")
    }
    return(ltag)
  }
  FGl <- data.table::copy(FG)
  FGl[, c("lAARl", "lALDERl") := list(AARl + YL, ALDERl + AL)]
  FGl[, c("AARl", "AARh", "ALDERl", "ALDERh") := list(NULL)]
  data.table::setnames(FGl, c("lAARl", "lALDERl"), c("AARl", "ALDERl"))
  tabkols <- setdiff(names(FGl), get_value_columns(names(FG), full = TRUE))
  lvals <- paste("Y", ltag(YL), "_A", ltag(AL), "_", vals, c("", ".f", ".a"), sep = "")
  data.table::setnames(FGl, unlist(lapply(vals, function(x) {
    paste(x, c("", ".f", ".a"), sep = "")
  })), lvals)
  FGl <- FGl[, c(tabkols, lvals), with = FALSE]
  data.table::setkeyv(FG, tabkols)
  data.table::setkeyv(FGl, tabkols)
  return(FGl)
}

#' @title set_lead_value
#' 
#' CAN REPLACE YALAGVAL, BUT MUST FIND A WAY OF USING IT IN ACCESS
#' MAKE NEW COLUMN "LAGVAL" 
#'
#' @param file 
#' @param yearlag 
#' @param vals 
set_lead_value <- function(file, yearlag = -1, vals = NULL){
  if(is.null(vals)) stop("vals must be specified to generate lead values")
  d <- data.table::copy(file)
  d[, lagAARl := AARl + yearlag]
  d[, c("AARl", "AARh") := list(NULL)]
  data.table::setnames(d, "lagAARl", "AARl")
  tabcols <- get_dimension_columns(names(d))
  # m/p means plus/minus
  lagprefix <- paste0("Y", ifelse(yearlag < 0, "p", "m"), abs(yearlag), "_A_") 
  oldvals <- paste0(rep(vals, each = 3), c("", ".f", ".a"))
  newvals <- paste0(lagprefix, allvals)
  data.table::setnames(d, old = allvals, new = newvals)
  d <- d[, mget(c(tabcols, newvals))]
  return(d)
}
